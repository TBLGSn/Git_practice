 1.- 为什么我们更偏向于有序


- 保持数据有序，是对下面一种思想的描述：有序的这种结构允许快速实现一些操作，但相对于无序所节省的开销一定要与维护有序这种结构所付出的开支保持平衡.

```
    从数据处理角度来看，有序性在很多情况下都能极大的提高计算的性能。
```
	
 - 以查找算法为例，对于无序线性表而言，最坏情况下，我们不得不与每一个元素进行比对，因此O(n)复杂度应属于最优。然而对于有序线性表而言，因为所有元素以按一定次序排列，我们可将时间复杂度优化到O(log n).
 -     或许有人会观察到这样的事实，从一个无序线性表中查找一个元素，最坏情况下，我们也无非经过n次比较便可以得到结果。而对于一个有序线性表，我们虽然可以将时间复杂度优化到O(log n),但我们可能付出O( n ^2 )进行排序。从这一角度来看，有序线性表的查找效率甚至比无序线性表的查找慢很多。
    从单次查找来看，事实确实是这样。然而倘若我们考虑 下面对于n 次查找的效率的比较：   
     无序: n次查找,平均来说要花费  ~n / 2 次比较,这达到了O( n )时间复杂度。
     有序:花费大约 ~ k * n *  log n 次比较进行排序，n次折半查找最坏情况下也不过是经过~ t * n *  log n 次比较 ,这样看来每次查找无非要经过（k + t）* logn 次比较。    
      (n：查找次数)
     
 -  时间复杂度从线性优化为对数级别。
 


----------


2.冒泡排序

 - 基本思想
 

  每一轮排序比较相邻的两个元素，如若逆序则交换两者位置，不难证明每一轮结束后，元素中最大（最小）的那个元素必定处于未排序部分最后的位置上，这时缩短无序部分的规模，从头开始进行一次排序。

 - 实现
```
void Bubble_Sort( int A[] ,int N)
{
    int i = 0;
	int j = N -1;
	int temp ;

	for( ; j >= 0 ;  j -- )
		for( i = 0; i < j ; i ++ )
			if( A[ i ] > A[ i + 1 ])
			{
				temp = A[ i ];
				A[ i ] = A[ i + 1 ];
				A[ i + 1] = temp;
			}

}
```

 - 算法改进
    不难证明，如果待排序部分已经有序，该算法的性能会变得很差。其原因在于---缺少对待排序部分是否已经有序的判断。我们希望当我们经过一轮排序后，如果剩下部分已经有序，我们便结束算法。事实上这不难实现，通过增加一个标示即可优化算法性能。

3.插入排序

    - 基本思路
     将待排序部分分为有序区和无序区，将无序区中元素一个个插入有序区中，使有序部分不断扩张，直到无序区中不在存在元素。
    - 实现
 
```
void Inser_Sort( int A[] ,int N)
{
    int P ;
	int j ;
	int temp ;

	for(  P = 1, j = N -1 ; j < N ;  P ++ )
	{	
		temp = A[ P ];
		for( j  = P ; j > 0 && A[ j - 1 ] > temp ; j -- )
			A[ j  ] = A[ j - 1 ];
	
		A[ j ] = temp;
	}
} 
```
 - 算法分析与改进
 - 1.考察下面这个例子

 5  7  4  9  6
 4个逆序:
 5 --- 4
 7 --- 4
 7 --- 6
 9 --- 6

 - 逆序数恰好是插入排序（非直接）执行的交换次数。
 
  - 解释：我们不妨直接考察算法运行到元素6时（内循环）：
    -要进行的比较次数无非是包含元素6的逆序个数（7 --- 6 和 9 --- 6） + 1 ，付出的代价也无非是再乘以一个常数。要进行的移动次数也无非是包含元素6的逆序个数。
    通过在每次移动交换操作时，增加两次常数操作，可以将算法更改为交换相邻元素算法。
     -   如此时在算法进行到 6 时，插入排序算法的做法是，用一临时变量保存 6 ，再经过比较，依次将 9 和 7 往后移动后，再将临时变量移动到空出来的位置。
     -   而我们现在增加一次常数操作。（用一临时变量保存 6 ,再经过比较,9 向后移动后，将 6 移动到 原来 9 的 位置，实现交换操作。再经过比较,7 向后移动后，将 6 移动到 原来 7 的 位置，实现交换操作。）。
     -   我们不难得到交换总次数与插入排序一样与此时逆序数相等，而后者与前者相对比可以得到：比较次数没有改变。唯一变化的是前者比后者少一个常数操作，因此两者交换的代价无非是 常数上的变化.
   - 交换两个不按原序排列的相邻元素恰好消除一个逆序，而一个排过序的数组没有逆序。而算法还有O( n )其余工作 ---从1开始到N-1的每个家都可能多一次比较操作。因此插入排序的应该运行情况是O( I + n )( I : 原始数组中的逆序数).

 - 2.插入排序平均情况下需要~n ^ 2/ 4 次比较，以及~ n ^ 2/ 4 次交换。
	（每轮排序为 当前逆序数 + 1 (如上文当算法运行到 6 时要经过 3 次比较），因此比较次数 为逆序总数 再加上 一个常数 * n。结合 “在一定假设下，N个互异数的数组的平均逆序数为N *（ N - 1 ）/ 4.”这一结论，不难证明平均情况下需要~n ^ 2/ 4 次比较。交换类似可证。）

 - 3.考虑该算法中元素的移动情况，不难得到：对于第 i 次循环，平均情况下移动元素的次数为i   / 2 + 2,而对于该算法的比较情况，对于已经有序的部分，我们却仍是采用对待无序线性表一样策略，一种改进策略是采用前面的折半查找策略减少比较次数（但元素移动次数不变）。



4.简单选择排序
 
  - 基本思路
     与插入排序类似，简单选择排序也将待排序部分分为有序和无序两类，不同之处在于选择排序还要求前一类算法（中最大值）不大于后一类（中最小者）。如此只需每次从后一类选出最小值，作为最大元素插入前一类中，即可使有序部分不断扩张。
  - 实现
```
void Select_Sort( int A[] ,int N)
{
    int i , j , k ;
	int temp ;

	for( i = 0; i < N -1 ; i ++ )
	{
		k = i;
		for( j = i +1 ; j < N ; j ++ )
			if( A[ j ] < A[ k ])
				k = j;
			if(k != j )
			{
				temp = A[ i ];
				A[ i ] = A[ k ];
				A[ k ] = temp;
			}
	}
}
```
 - 算法分析与改进
 -  因为简单选择排序是从无序后一类中选出最小值的策略，其比较操作的最坏时间复杂度，最好时间复杂度，平均时间复杂度均为O(n ^ 2 )。而其移动记录次数，最好情况下为 0 次， 最坏情况为3（ n  -  1 ）次。同样采用更好的数据结构，可以使得从后一类中选出最小值操作的复杂度降至O( log n ),从而使选择排序效率提高到O( n * log n).
 


----------
5.一些简单排序算法的下界

```
成员存数的数组的一个逆序是指数组中存在具有性质 i < j ,但A[ i ] > A[ j ]的序偶( A[ i],A[ j ]).
```

```
在一定假设下，N个互异数的数组的平均逆序数为N *（ N - 1 ）/ 4.
(详细证明以及假设见数据结构与算法分析：c语言描述)
```
```
通过交换相邻元素进行的任何排序算法平均需要Ω（ n ^ 2 )时间。

证明:每次交换只减少一个逆序，而平均逆序数是n * ( n - 1) / 4*
```

<注意上面的一些分析，如：要进行的比较次数无非是包含元素6的逆序个数（7 --- 6 和 9 --- 6） + 1 ，付出的代价也无非是再乘以一个常数。此时到的"比较次数“并不是算法每次执行所要进行的真实比较次数，真实比较次数本文用付出的代价指出>
